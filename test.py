import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.utils.data import DataLoader
from torchvision import datasets, transforms, models
from torchvision.utils import make_grid
from config import *
import numpy as np
from models.CnnModels import *
from data_utils.data_loaders import *
import argparse
from datetime import datetime

from torch.nn import CrossEntropyLoss
from torchtext.legacy.data import Iterator

from models.models_utils import *
from utils import *
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from models.Shallow_ML_models import *
import sklearn.metrics
import sys
import traceback
from models.CnnModels import *
from models.AnnModels import *
from models.RnnModels import *
from models.TransferLearnModels import *
from data_utils.data_loaders import *
from models.model_trainers_testers import *
from sklearn.model_selection import GridSearchCV
import xgboost as xgb
from sklearn.ensemble import RandomForestClassifier
from sklearn.neighbors import KNeighborsClassifier
import itertools
from config import *
import os
import pickle
import matplotlib.pyplot as plt
import sklearn.metrics as metrics
import seaborn as sns
import pandas as pd
import numpy as np
import torch.nn as nn
import sys
from sklearn.model_selection import GridSearchCV
import json
from tqdm import tqdm








def split_opcodes(input_file_path,  opcode_len=-1):
    """
    input_class_dir contains opcode json file.
    Create train and test split for this json file
    """
    opcode_path = r'C:\Users\Lenovo\Desktop\new\malware_detect2-master'
    split_json = r'C:\Users\Lenovo\Desktop\new\malware_detect2-master\split.json'
    opcode = open(input_file_path, 'r')
    opcodes = [opcode_len]

    opcodes = opcode.read().splitlines()

    if opcode_len != -1:
        opcodes = opcodes[0:opcode_len]

    split_opcode = open(split_json, 'w')

    file_dict = {'text': opcodes}
    json.dump(file_dict, split_opcode)
    split_opcode.write('\n')


def test_rnn(model=None, val_loader=None):
    tqdm_test_descr_format = "Testing RNN model: Batch Accuracy = {:02.4f}%"
    tqdm_test_descr = tqdm_test_descr_format.format(0)
    tqdm_test_obj = tqdm(val_loader, desc=tqdm_test_descr)
    num_of_batches = len(val_loader)

    model.eval()
    with torch.no_grad():
        for b, batch in enumerate(tqdm_test_obj):
            batch.text = batch.text.to(device)
            # batch.label = batch.label.to(device)
            predictions = model(batch.text)
            predicted = torch.max(predictions.data, 1)[1]

    return predicted


class_names = ['Backdoor.Win33.MiniDuke.h', 'Virus.Win32.Pioneer.dx', 'HEURTrojan.Win32.CozyDuke.gen',
               'HEURTrojan.Win32.Generic', 'Trojan.Win41.CloudLook.a', 'Trojan.Win32.Havex.p']

print("start")

TEXT = torchtext.legacy.data.Field()
file_path = r'C:\Users\Lenovo\Desktop\new\malware_detect2-master\data\exec_files\org_dataset_opcodes\Backdoor.Win33.MiniDuke.h\3d0b1f970eaeeabf9372ffc1ad7e61226632904cf0311ea8f872ddbfd34a3a2a.txt'
split_opcodes(file_path, 10)

data_path = r'C:\Users\Lenovo\Desktop\new\malware_detect2-master\data\exec_files\org_dataset_opcodes_split_5000\Trojan.Win32.Havex.p\test_Trojan.Win32.Havex.p.json'

fields = {'text': ('text', TEXT)}
test_data = torchtext.legacy.data.TabularDataset(
    path=data_path,
    format='json',
    fields=fields
)
TEXT.build_vocab(test_data)
test_iterator = torchtext.legacy.data.BucketIterator((test_data),
                                                     batch_size=512,
                                                     sort=False,
                                                     shuffle=True,
                                                     repeat=False,
                                                     device='cpu')

model = torch.load(
    r'C:\Users\Lenovo\Desktop\new\malware_detect2-master\logs\01-Sep-2021_15_41_05\rnn_experiment_2\RNNMalware_Model1.pt')
# model = create_deep_opcode_model(model_params)
predicte = test_rnn(model=model, val_loader=test_iterator)

print(predicte)
print(class_names[predicte[0]])
