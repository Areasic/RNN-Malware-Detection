from models.CnnModels import *
from tqdm import tqdm
from subprocess import Popen, PIPE

def generate_opcode(bin_filename, text_filename, debug=False):
    list_of_cmd_args = [
        ['objdump', '-j .text', '-D', bin_filename],
        ['objdump', '-j CODE', '-D', bin_filename],
        ['objdump', '-d', bin_filename]
    ]

    got_upcode = False
    asm_code = ''

    for cmd_num, cmd_args in enumerate(list_of_cmd_args):
        try:
            if debug:
                print(f'cmd_num = {cmd_num}')
                print(f'cmd_args = {" ".join(cmd_args)}')
            process = Popen(cmd_args, stdout=PIPE, stderr=PIPE)
            p_out, p_err = process.communicate()
            if debug:
                print(p_out)
            asm_code = str(p_out).split('\\n')
        except ValueError:
            got_upcode = False
        else:
            if len(asm_code) > 5:
                got_upcode = True

        if got_upcode:
            break

    if got_upcode:
        with open(text_filename, 'w+') as f:
            for line in asm_code:
                line = line.split('\\t')
                if len(line) > 2:
                    opcode_line = line[2]
                    opcode_line = opcode_line.split(' ')
                    if len(opcode_line) > 0:
                        f.write(opcode_line[0])
                        f.write('\n')

    else:
        # TODO some files are empty. check generate_opcode
        if debug:
            print(f'Giving up on {bin_filename}')

def process_opcodes_bulk(input_dir, output_dir=ORG_DATASET_OPCODES_PATH, max_files=0):
    if not os.path.isdir(output_dir):
        os.mkdir(output_dir)

    list_dirs = os.listdir(input_dir)
    with multiprocessing.Pool(multiprocessing.cpu_count()) as pool:

        jobs = []
        results = []
        total_count = 0

        for dirname in list_dirs:
            list_files = os.listdir(os.path.join(input_dir, dirname))
            count = 0
            for filename in list_files:
                input_filename = os.path.join(input_dir, dirname, filename)
                try:
                    output_filename = os.path.splitext(os.path.basename(input_filename))[0] + '.txt'
                    output_class_dir = os.path.join(output_dir, dirname)
                    if not os.path.isdir(output_class_dir):
                        os.mkdir(output_class_dir)
                    output_filename = os.path.join(output_dir, dirname, output_filename)

                    jobs.append(
                        pool.apply_async(generate_opcode, (input_filename, output_filename)))
                    count += 1
                    if max_files > 0 and max_files == count:
                        break
                except:
                    print('Ignoring ', filename)

            total_count += count
        tqdm_desc = 'Extracting opcodes from Malware bins'
        for job in tqdm(jobs, desc=tqdm_desc):
            results.append(job.get())

if __name__ == '__main__':
    max_files = 0
    process_opcodes_bulk(ORG_DATASET_PATH, max_files=max_files)